!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Common routines for computing transport increments at the end of
!!        the transport step, for adjoint model.

module atl_end_transport_step_alg_mod

  use base_mesh_config_mod,           only: topology, topology_non_periodic
  use boundaries_config_mod,          only: limited_area
  use check_configuration_mod,        only: check_any_eqn_consistent, &
                                            check_any_wt_eqn_conservative
  use constants_mod,                  only: i_def, r_tran, l_def
  use end_of_transport_step_alg_mod,  only: build_up_flux
  use adj_end_transport_step_alg_mod, only: adj_build_up_flux
  use finite_element_config_mod,      only: element_order_h, &
                                            element_order_v
  use fs_continuity_mod,              only: W2, W2H, W2V
  use function_space_mod,             only: function_space_type
  use function_space_collection_mod,  only: function_space_collection
  use io_config_mod,                  only: subroutine_timers
  use log_mod,                        only: log_event, LOG_LEVEL_ERROR
  use mesh_mod,                       only: mesh_type
  use mesh_collection_mod,            only: mesh_collection
  use operator_mod,                   only: operator_type
  use adj_dg_matrix_vector_kernel_mod, &
                                      only: adj_dg_matrix_vector_kernel_type
  use r_tran_field_mod,               only: r_tran_field_type
  use r_tran_operator_mod,            only: r_tran_operator_type
  use timer_mod,                      only: timer
  use transport_config_mod,           only: dry_field_name
  use transport_constants_mod,        only: get_directional_im3_div_r_tran
  use transport_enumerated_types_mod, only: direction_3d, &
                                            direction_h,  &
                                            direction_v
  use transport_metadata_mod,         only: transport_metadata_type
  use transport_runtime_alg_mod,      only: transport_runtime_type
  use tl_transport_runtime_collection_mod, &
                                      only: tl_transport_runtime

  implicit none

  private

  public  :: atl_end_advective_step_alg
  public  :: atl_end_conservative_step_alg

contains

  !> @brief Adjoint of common end-of-step code for T.L. advective transport schemes.
  !>        Occurs near the start of the adjoint step due to adjoint ordering.
  !> @param[in,out] field_np1          Field at the end of the transport step
  !!                                   to be computed.
  !> @param[in]     field_in           Field at the beginning of this transport
  !!                                   step.
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting the field
  subroutine atl_end_advective_step_alg( field_np1, field_in, transport_metadata )

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_in
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Enforce a min value if required
    if ( transport_metadata%get_enforce_min_value() ) then
      call log_event('A.T.L.: enforcing min value advective not ' // &
                     'yet implemented', LOG_LEVEL_ERROR)
    end if

    ! At the end do the overwrite step for the blending zone
    if ( limited_area .and. topology == topology_non_periodic ) then
      call log_event('A.T.L.: LAM overwrite not yet implemented', LOG_LEVEL_ERROR)
    end if

  end subroutine atl_end_advective_step_alg

  !> @brief Adjoint of common end-of-step code for T.L. conservative transport schemes.
  !>        Occurs near the start of the adjoint step due to adjoint ordering.
  !> @param[in,out] field_np1                 Field at the end of the transport step
  !!                                          to be computed.
  !> @param[in]     field_in                  Field at the beginning of this transport
  !!                                          step, which may be saved in the transport
  !!                                          runtime object if this field is the "dry
  !!                                          field".
  !> @param[in,out] flux                      The mass flux for this transport step.
  !> @param[in]     transport_metadata        Contains the configuration options for
  !!                                          transporting the field.
  subroutine atl_end_conservative_step_alg( field_np1, field_in, flux, &
                                            transport_metadata )

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_in
    type(r_tran_field_type),       intent(inout) :: flux
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Internal variables
    integer(kind=i_def)                   :: mesh_id, step
    type(mesh_type),              pointer :: mesh
    type(r_tran_field_type)               :: increment
    type(r_tran_field_type)               :: sum_flux
    type(r_tran_field_type),      pointer :: field_start
    type(r_tran_operator_type),   pointer :: div
    type(function_space_type),    pointer :: w2_fs
    logical(kind=l_def)                   :: enforce_min_value
    logical(kind=l_def)                   :: final_split_step
    logical(kind=l_def)                   :: is_dry_field
    logical(kind=l_def)                   :: store_dry_field

    ! Pointers for accessing tl_transport_runtime fields
    type(r_tran_field_type),      pointer :: flux_ptr

    ! Extract transport runtime
    mesh => field_np1 % get_mesh()
    mesh_id = mesh % get_id()
    enforce_min_value = transport_metadata % get_enforce_min_value()
    is_dry_field = ( trim( transport_metadata % get_name() ) == trim(dry_field_name))

    ! Determine whether this is the final split step
    final_split_step = ( tl_transport_runtime % get_tracer_step_ctr() &
                         == tl_transport_runtime % get_num_dry_steps() )

    ! ------------------------------------------------------------------------ !
    ! Store dry field details
    ! ------------------------------------------------------------------------ !
    ! Store field in transport_runtime for conservative transport
    ! if this is the underlying dry field
    if ( is_dry_field ) then
      store_dry_field = (                                                      &
          check_any_eqn_consistent() .or. check_any_wt_eqn_conservative()      &
      )
    end if
    if ( is_dry_field .and. store_dry_field ) then
      call log_event(                                                          &
              'A.T.L.: storage of dry fields not yet implemented',             &
              LOG_LEVEL_ERROR                                                  &
      )
    end if

    ! ------------------------------------------------------------------------ !
    ! Blending zone update
    ! ------------------------------------------------------------------------ !
    if ( limited_area .and. topology == topology_non_periodic ) then
      call log_event('A.T.L.: conservative overwrite blending zone not ' // &
                     'yet implemented', LOG_LEVEL_ERROR)
    end if

    ! ------------------------------------------------------------------------ !
    ! Compute increment from all split steps
    ! ------------------------------------------------------------------------ !

    if ( final_split_step ) then

      field_start => tl_transport_runtime % get_field_n()
      div => get_directional_im3_div_r_tran( mesh_id, direction_3d )
      w2_fs => function_space_collection % get_fs( mesh, element_order_h, element_order_v, W2 )
      call increment % initialise( field_np1 % get_function_space() )
      call sum_flux % initialise( w2_fs )
      call invoke( setval_c( increment, 0.0_r_tran ), &
                   setval_c( sum_flux, 0.0_r_tran ) )

      ! ---------------------------------------------------------------------- !
      ! Conservative clipping by limiting flux, if specified
      ! ---------------------------------------------------------------------- !

      if ( enforce_min_value ) then
        call log_event('A.T.L.: conservative enforce min value not ' // &
                        'yet implemented', LOG_LEVEL_ERROR)
      else
        ! Compute updated field using flux for whole transport step
        ! dt is hidden inside flux
        call invoke( inc_X_plus_Y( field_start, field_np1 ),                       &
                     inc_X_minus_Y( increment, field_np1 ),                        &
                     setval_c( field_np1, 0.0_r_tran ),                            &
                     adj_dg_matrix_vector_kernel_type( increment, sum_flux, div ) )
      end if

      ! Get final field at end of transport
      ! Sum the fluxes from all previous steps
      call adj_build_up_flux( sum_flux, flux, tl_transport_runtime, transport_metadata )

    ! ------------------------------------------------------------------------ !
    ! Not final step
    ! ------------------------------------------------------------------------ !
    else
      ! Enforce min value advective value here
      if ( enforce_min_value ) then
        call log_event('A.T.L.: conservative enforce min value not ' // &
                        'yet implemented', LOG_LEVEL_ERROR)
      end if
    end if

    if (.not. final_split_step) then
      step = tl_transport_runtime%get_tracer_step_ctr()
      flux_ptr => tl_transport_runtime % get_flux( mesh_id, step )
      call invoke( inc_X_plus_Y( flux, flux_ptr ), &
                   setval_c( flux_ptr, 0.0_r_tran ) )
    end if

  end subroutine atl_end_conservative_step_alg

end module atl_end_transport_step_alg_mod
