@@ -10,10 +10,10 @@
     use function_space_collection_mod, only : function_space_collection
     use w3v_advective_update_kernel_mod, only : w3v_advective_update_kernel_type
     use adj_w3v_advective_update_kernel_mod, only : adj_w3v_advective_update_kernel_type
-    use finite_element_config_mod, only : element_order
+    use finite_element_config_mod, only : element_order_h, element_order_v
     use fs_continuity_mod, only : w2, w3
     use operator_mod, only : operator_type
-    use constants_mod, only : i_def, r_def
+    use constants_mod, only : i_def, r_def, r_tran
     use setop_random_kernel_mod, only : setop_random_kernel_type
     use log_mod, only : log_event, log_level_error, log_level_info, log_scratch_space
     real(kind=r_def), parameter :: overall_tolerance = 1500.0_r_def
@@ -28,51 +28,41 @@
     type(operator_type) :: m3_inv
     type(field_type) :: advective_increment_input
     type(field_type) :: tracer_input
-    type(field_type) :: wind_input
     real(kind=r_def) :: advective_increment_inner_prod
     real(kind=r_def) :: tracer_inner_prod
-    real(kind=r_def) :: wind_inner_prod
-    real(kind=r_def) :: inner1
+    real(kind=r_tran) :: inner1
     real(kind=r_def) :: advective_increment_advective_increment_input_inner_prod
     real(kind=r_def) :: tracer_tracer_input_inner_prod
-    real(kind=r_def) :: wind_wind_input_inner_prod
-    real(kind=r_def) :: inner2
+    real(kind=r_tran) :: inner2
     real(kind=r_def) :: MachineTol
     real(kind=r_def) :: relative_diff
 
-    vector_space_w2_ptr => function_space_collection%get_fs(mesh,element_order,w2)
-    vector_space_w3_ptr => function_space_collection%get_fs(mesh,element_order,w3)
+    vector_space_w2_ptr => function_space_collection%get_fs(mesh,element_order_h,element_order_v,w2)
+    vector_space_w3_ptr => function_space_collection % get_fs(mesh, element_order_h, element_order_v, w3, 6, ndata_first = .false.)
     call advective_increment%initialise(vector_space=vector_space_w3_ptr, name='advective_increment')
     call tracer%initialise(vector_space=vector_space_w3_ptr, name='tracer')
     call wind%initialise(vector_space=vector_space_w2_ptr, name='wind')
     call m3_inv%initialise(vector_space_w3_ptr, vector_space_w3_ptr)
     call advective_increment_input%initialise(vector_space=vector_space_w3_ptr, name='advective_increment_input')
     call tracer_input%initialise(vector_space=vector_space_w3_ptr, name='tracer_input')
-    call wind_input%initialise(vector_space=vector_space_w2_ptr, name='wind_input')
     advective_increment_inner_prod = 0.0_r_def
     tracer_inner_prod = 0.0_r_def
-    wind_inner_prod = 0.0_r_def
     ! Initialise arguments and call the tangent-linear kernel.
     call invoke(setval_random(advective_increment), setval_x(advective_increment_input, advective_increment), &
-&setval_random(tracer), setval_x(tracer_input, tracer), setval_random(wind), setval_x(wind_input, wind), &
+&setval_random(tracer), setval_x(tracer_input, tracer), setval_random(wind), &
 &setop_random_kernel_type(m3_inv), w3v_advective_update_kernel_type(advective_increment, tracer, wind, m3_inv), &
-&x_innerproduct_x(advective_increment_inner_prod, advective_increment), x_innerproduct_x(tracer_inner_prod, tracer), &
-&x_innerproduct_x(wind_inner_prod, wind))
-    inner1 = 0.0_r_def
-    inner1 = inner1 + advective_increment_inner_prod
-    inner1 = inner1 + tracer_inner_prod
-    inner1 = inner1 + wind_inner_prod
+&x_innerproduct_x(advective_increment_inner_prod, advective_increment), x_innerproduct_x(tracer_inner_prod, tracer))
+    inner1 = 0.0_r_tran
+    inner1 = inner1 + real(advective_increment_inner_prod, r_tran)
+    inner1 = inner1 + real(tracer_inner_prod, r_tran)
     advective_increment_advective_increment_input_inner_prod = 0.0_r_def
     tracer_tracer_input_inner_prod = 0.0_r_def
-    wind_wind_input_inner_prod = 0.0_r_def
     call invoke(adj_w3v_advective_update_kernel_type(advective_increment, tracer, wind, m3_inv), &
 &x_innerproduct_y(advective_increment_advective_increment_input_inner_prod, advective_increment, advective_increment_input), &
-&x_innerproduct_y(tracer_tracer_input_inner_prod, tracer, tracer_input), x_innerproduct_y(wind_wind_input_inner_prod, wind, &
-&wind_input))
-    inner2 = 0.0_r_def
-    inner2 = inner2 + advective_increment_advective_increment_input_inner_prod
-    inner2 = inner2 + tracer_tracer_input_inner_prod
-    inner2 = inner2 + wind_wind_input_inner_prod
+&x_innerproduct_y(tracer_tracer_input_inner_prod, tracer, tracer_input))
+    inner2 = 0.0_r_tran
+    inner2 = inner2 + real(advective_increment_advective_increment_input_inner_prod, r_tran)
+    inner2 = inner2 + real(tracer_tracer_input_inner_prod, r_tran)
     ! Test the inner-product values for equality, allowing for the precision of the active variables
     MachineTol = SPACING(MAX(ABS(inner1), ABS(inner2)))
     relative_diff = ABS(inner1 - inner2) / MachineTol
