!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Module to get inner product of fields from transport runtime at r_tran precision

module inner_from_runtime_rtran_alg_mod

  use constants_mod,                       only : r_tran, r_def, i_def
  use tl_transport_runtime_collection_mod, &
                                           only : tl_transport_runtime
  use transport_runtime_alg_mod,           only : transport_runtime_type
  use transport_runtime_collection_mod,    only : get_transport_runtime
  use r_tran_field_mod,                    only : r_tran_field_type
  use mesh_mod,                            only : mesh_type
  use log_mod,                             only : log_event,       &
                                                  LOG_LEVEL_DEBUG, &
                                                  log_scratch_space

  implicit none

  private
  public :: flux_prod_rtran
  public :: flux_inp_prod_rtran
  public :: dry_flux_prod_rtran
  public :: dry_flux_inp_prod_rtran
  public :: rho_d_prod_rtran
  public :: rho_d_inp_prod_rtran
  public :: field_n_prod_rtran
  public :: field_n_inp_prod_rtran

  contains
  !=============================================================================
  !> @brief Increments the rtran inner product by flux.flux
  !> @param[in,out]  inner         Inner product (rtran) to increment
  !> @param[in]      mesh_id       The mesh id
  !> @param[in]      flux_sf       (Optional) scale factor for the increment
  subroutine flux_prod_rtran( inner, mesh_id, flux_sf )

    implicit none

    real(kind=r_tran),        intent(inout) :: inner
    integer(kind=i_def),         intent(in) :: mesh_id
    real(kind=r_tran), intent(in), optional :: flux_sf

    type(r_tran_field_type), pointer :: flux_ptr
    integer(kind=i_def)              :: step
    integer(kind=i_def)              :: num_steps
    real(kind=r_def)                 :: flux_inner_prod

    num_steps = tl_transport_runtime % get_num_dry_steps()
    do step = 1, num_steps - 1
      flux_inner_prod = 0.0_r_def
      flux_ptr => tl_transport_runtime % get_flux( mesh_id, step )
      call invoke( x_innerproduct_x( flux_inner_prod, flux_ptr ) )

      if( present(flux_sf) ) then
        inner = inner + real( flux_inner_prod, r_tran )*flux_sf
        call invoke( inc_a_times_X(flux_sf, flux_ptr) )
        write(log_scratch_space, *) "Transport runtime flux(step = ", step, ") inner prod = ", &
                                    real( flux_inner_prod, r_tran )*flux_sf
      else
        inner = inner + real( flux_inner_prod, r_tran )
        write(log_scratch_space, *) "Transport runtime flux(step = ", step, ") inner prod = ", &
                                    real( flux_inner_prod, r_tran )
      end if
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    end do

  end subroutine flux_prod_rtran

  !=============================================================================
  !> @brief Increments the rtran inner product by flux.flux_inp
  !> @param[in,out]  inner         Inner product (rtran) to increment
  !> @param[in]      mesh_id       The mesh id
  !> @param[in]      flux_input    Flux field at start of adjoint test
  subroutine flux_inp_prod_rtran( inner, mesh_id, flux_input )

    implicit none

    real(kind=r_tran), intent(inout)                  :: inner
    integer(kind=i_def), intent(in)                   :: mesh_id
    type(r_tran_field_type), dimension(:), intent(in) :: flux_input

    type(r_tran_field_type), pointer :: flux_ptr
    integer(kind=i_def)              :: step
    integer(kind=i_def)              :: num_steps
    real(kind=r_def)                 :: flux_inner_prod

    num_steps = tl_transport_runtime % get_num_dry_steps()
    do step = 1, num_steps - 1
      flux_inner_prod = 0.0_r_def
      flux_ptr => tl_transport_runtime % get_flux( mesh_id, step )
      call invoke( x_innerproduct_y( flux_inner_prod,      &
                                     flux_ptr,             &
                                     flux_input(step) ) )
      inner = inner + real( flux_inner_prod, r_tran )
    end do

  end subroutine flux_inp_prod_rtran

  !=============================================================================
  !> @brief Increments the rtran inner product by dry_flux.dry_flux
  !> @param[in,out]  inner         Inner product (rtran) to increment
  !> @param[in]      mesh_id       The mesh id
  !> @param[in]      dry_flux_sf   (Optional) scale factor for the increment
  subroutine dry_flux_prod_rtran( inner, mesh_id, dry_flux_sf )

    implicit none

    real(kind=r_tran),        intent(inout) :: inner
    integer(kind=i_def),         intent(in) :: mesh_id
    real(kind=r_tran), intent(in), optional :: dry_flux_sf

    type(r_tran_field_type), pointer :: dry_flux_ptr
    integer(kind=i_def)              :: step
    integer(kind=i_def)              :: num_steps
    real(kind=r_def)                 :: dry_flux_inner_prod

    num_steps = tl_transport_runtime % get_num_dry_steps()
    do step = 1, num_steps
      dry_flux_inner_prod = 0.0_r_def
      dry_flux_ptr => tl_transport_runtime % get_dry_flux( mesh_id, step )
      call invoke( x_innerproduct_x( dry_flux_inner_prod, dry_flux_ptr ) )

      if( present(dry_flux_sf) ) then
        inner = inner + real( dry_flux_inner_prod, r_tran )*dry_flux_sf
        call invoke( inc_a_times_X(dry_flux_sf, dry_flux_ptr) )
        write(log_scratch_space, *) "Transport runtime dry_flux(step = ", step, ") inner prod = ", &
                                    real( dry_flux_inner_prod, r_tran )*dry_flux_sf
      else
        inner = inner + real( dry_flux_inner_prod, r_tran )
        write(log_scratch_space, *) "Transport runtime dry_flux(step = ", step, ") inner prod = ", &
                                    real( dry_flux_inner_prod, r_tran )
      end if
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    end do

  end subroutine dry_flux_prod_rtran

  !=============================================================================
  !> @brief Increments the rtran inner product by dry_flux.dry_flux_inp
  !> @param[in,out]  inner           Inner product (rtran) to increment
  !> @param[in]      mesh_id         The mesh id
  !> @param[in]      dry_flux_input  Dry flux field at start of adjoint test
  subroutine dry_flux_inp_prod_rtran( inner, mesh_id, dry_flux_input )

    implicit none

    real(kind=r_tran), intent(inout)                  :: inner
    integer(kind=i_def), intent(in)                   :: mesh_id
    type(r_tran_field_type), dimension(:), intent(in) :: dry_flux_input

    type(r_tran_field_type), pointer :: dry_flux_ptr
    integer(kind=i_def)              :: step
    integer(kind=i_def)              :: num_steps
    real(kind=r_def)                 :: dry_flux_inner_prod

    num_steps = tl_transport_runtime % get_num_dry_steps()
    do step = 1, num_steps
      dry_flux_inner_prod = 0.0_r_def
      dry_flux_ptr => tl_transport_runtime % get_dry_flux( mesh_id, step )
      call invoke( x_innerproduct_y( dry_flux_inner_prod,      &
                                     dry_flux_ptr,             &
                                     dry_flux_input(step) ) )
      inner = inner + real( dry_flux_inner_prod, r_tran )
    end do

  end subroutine dry_flux_inp_prod_rtran

  !=============================================================================
  !> @brief Increments the rtran inner product by rho_d.rho_d
  !> @param[in,out]  inner         Inner product (rtran) to increment
  !> @param[in]      mesh          The mesh
  !> @param[in]      rho_d_sf      (Optional) scale factor for the increment
  subroutine rho_d_prod_rtran( inner, mesh, rho_d_sf )

    implicit none

    real(kind=r_tran),        intent(inout) :: inner
    type(mesh_type),    pointer, intent(in) :: mesh
    real(kind=r_tran), intent(in), optional :: rho_d_sf

    type(r_tran_field_type),      pointer :: rho_d_ptr
    integer(kind=i_def)                   :: step
    integer(kind=i_def)                   :: num_steps
    real(kind=r_def)                      :: rho_d_inner_prod
    type(transport_runtime_type), pointer :: transport_runtime
    integer(kind=i_def)                   :: mesh_id

    mesh_id = mesh % get_id()
    transport_runtime => get_transport_runtime( mesh )
    num_steps = transport_runtime % get_num_dry_steps()
    do step = 1, num_steps + 1
      rho_d_inner_prod = 0.0_r_def
      rho_d_ptr => transport_runtime % get_rho_d( mesh_id, step )
      call invoke( x_innerproduct_x( rho_d_inner_prod, rho_d_ptr ) )

      if( present(rho_d_sf) ) then
        inner = inner + real( rho_d_inner_prod, r_tran )*rho_d_sf
        call invoke( inc_a_times_X(rho_d_sf, rho_d_ptr) )
        write(log_scratch_space, *) "Transport runtime rho_d(step = ", step, ") inner prod = ", &
                                    real( rho_d_inner_prod, r_tran )*rho_d_sf
      else
        inner = inner + real( rho_d_inner_prod, r_tran )
        write(log_scratch_space, *) "Transport runtime rho_d(step = ", step, ") inner prod = ", &
                                    real( rho_d_inner_prod, r_tran )
      end if
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    end do

  end subroutine rho_d_prod_rtran

  !=============================================================================
  !> @brief Increments the rtran inner product by rho_d.rho_d_inp
  !> @param[in,out]  inner         Inner product (rtran) to increment
  !> @param[in]      mesh          The mesh
  !> @param[in]      rho_d_input   Density field at start of adjoint test
  subroutine rho_d_inp_prod_rtran( inner, mesh, rho_d_input )

    implicit none

    real(kind=r_tran),                  intent(inout) :: inner
    type(mesh_type),              pointer, intent(in) :: mesh
    type(r_tran_field_type), dimension(:), intent(in) :: rho_d_input

    type(r_tran_field_type),      pointer :: rho_d_ptr
    integer(kind=i_def)                   :: step
    integer(kind=i_def)                   :: num_steps
    real(kind=r_def)                      :: rho_d_inner_prod
    type(transport_runtime_type), pointer :: transport_runtime
    integer(kind=i_def)                   :: mesh_id

    mesh_id = mesh % get_id()
    transport_runtime => get_transport_runtime( mesh )
    num_steps = transport_runtime % get_num_dry_steps()
    do step = 1, num_steps + 1
      rho_d_inner_prod = 0.0_r_def
      rho_d_ptr => transport_runtime % get_rho_d( mesh_id, step )
      call invoke( x_innerproduct_y( rho_d_inner_prod,      &
                                     rho_d_ptr,             &
                                     rho_d_input(step) ) )
      inner = inner + real( rho_d_inner_prod, r_tran )
    end do

  end subroutine rho_d_inp_prod_rtran

  !=============================================================================
  !> @brief Increments the rtran inner product by field_n.field_n
  !> @param[in,out]  inner         Inner product (rtran) to increment
  !> @param[in]      field_n_sf    (Optional) scale factor for the increment
  subroutine field_n_prod_rtran( inner, field_n_sf )

    implicit none

    real(kind=r_tran),        intent(inout) :: inner
    real(kind=r_tran), intent(in), optional :: field_n_sf

    type(r_tran_field_type), pointer :: field_n_ptr
    real(kind=r_def)                 :: field_n_inner_prod

    field_n_inner_prod = 0.0_r_def
    field_n_ptr => tl_transport_runtime % get_field_n()
    call invoke( x_innerproduct_x( field_n_inner_prod, field_n_ptr ) )

    if( present(field_n_sf) ) then
      inner = inner + real( field_n_inner_prod, r_tran )*field_n_sf
      call invoke( inc_a_times_X(field_n_sf, field_n_ptr) )
      write(log_scratch_space, *) "Transport runtime field_n inner prod = ", &
                                  real( field_n_inner_prod, r_tran )*field_n_sf
    else
      inner = inner + real( field_n_inner_prod, r_tran )
      write(log_scratch_space, *) "Transport runtime field_n inner prod = ", &
                                  real( field_n_inner_prod, r_tran )
    end if
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

  end subroutine field_n_prod_rtran

  !=============================================================================
  !> @brief Increments the rtran inner product by field_n.field_n_inp
  !> @param[in,out]  inner          Inner product (rtran) to increment
  !> @param[in]      field_n_input  Field at timestep n at start of adjoint test
  subroutine field_n_inp_prod_rtran( inner, field_n_input )

    real(kind=r_tran), intent(inout)    :: inner
    type(r_tran_field_type), intent(in) :: field_n_input

    type(r_tran_field_type), pointer :: field_n_ptr
    real(kind=r_def)                 :: field_n_inner_prod

    field_n_inner_prod = 0.0_r_def
    field_n_ptr => tl_transport_runtime % get_field_n()
    call invoke( x_innerproduct_y( field_n_inner_prod,      &
                                   field_n_ptr,             &
                                   field_n_input ) )
    inner = inner + real( field_n_inner_prod, r_tran )

  end subroutine field_n_inp_prod_rtran

end module inner_from_runtime_rtran_alg_mod
