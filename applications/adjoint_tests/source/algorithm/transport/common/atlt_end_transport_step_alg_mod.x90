!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module containing adjoint test for atl_end_transport_step_alg_mod functions

module atlt_end_transport_step_alg_mod

  use r_tran_field_mod,                    only : r_tran_field_type
  use function_space_mod,                  only : function_space_type
  use constants_mod,                       only : r_def, i_def, &
                                                  l_def, r_tran
  use log_mod,                             only : log_event,         &
                                                  log_scratch_space, &
                                                  LOG_LEVEL_INFO,    &
                                                  LOG_LEVEL_DEBUG,   &
                                                  LOG_LEVEL_ERROR
  use mesh_mod,                            only : mesh_type
  use finite_element_config_mod,           only : element_order_h, &
                                                  element_order_v
  use fs_continuity_mod,                   only : W2, W3
  use function_space_collection_mod,       only : function_space_collection
  use transport_metadata_collection_mod,   only : transport_metadata_collection
  use transport_metadata_mod,              only : transport_metadata_type
  use tl_transport_runtime_collection_mod, &
                                           only : tl_transport_runtime
  use transport_runtime_alg_mod,           only : transport_runtime_type
  use transport_runtime_collection_mod,    only : get_transport_runtime
  use inner_from_runtime_rtran_alg_mod,    only : dry_flux_prod_rtran, &
                                                  dry_flux_inp_prod_rtran, &
                                                  flux_prod_rtran, &
                                                  flux_inp_prod_rtran, &
                                                  rho_d_prod_rtran, &
                                                  rho_d_inp_prod_rtran, &
                                                  field_n_prod_rtran, &
                                                  field_n_inp_prod_rtran
  use init_from_runtime_alg_mod,           only : init_atl_end_con_step_fields

  implicit none

  private
  public :: atlt_end_adv_step_alg
  public :: atlt_end_con_step_alg

  contains

  !=============================================================================
  !> @brief   Adjoint test for atl_end_advective_step_alg.
  !> @details Passes if adjoint is transpose of tangent linear.
  !>          Determined by testing the equality of inner products <Mx, Mx> and <AMx, x>,
  !>          where M is the tangent linear and A is the adjoint.
  !> @param[in]  mesh         The model mesh
  subroutine atlt_end_adv_step_alg( mesh )

    use tl_end_of_transport_step_alg_mod,    only : tl_end_of_advective_step_alg
    use atl_end_transport_step_alg_mod,      only : atl_end_advective_step_alg

    implicit none

    ! Arguments
    type(mesh_type), pointer, intent(in) :: mesh

    ! Arguments for tl and adj calls
    type(r_tran_field_type)        :: field_np1
    type(r_tran_field_type)        :: field_in
    type(transport_metadata_type), pointer :: transport_metadata

    ! Copies of input fields used in inner products
    type(r_tran_field_type)                            :: field_np1_input
    type(r_tran_field_type)                            :: field_in_input

    ! Variables for initialising fields
    type(function_space_type), pointer :: vector_space_w3_ptr

    ! Inner products
    real(kind=r_tran) :: inner1
    real(kind=r_def) :: field_np1_inner_prod
    real(kind=r_def) :: field_in_inner_prod
    real(kind=r_tran) :: inner2
    real(kind=r_def) :: fnp1_fnp1_input_inner_prod
    real(kind=r_def) :: fi_fi_input_inner_prod

    ! Test parameters and variables
    real(kind=r_tran), parameter :: overall_tolerance = 1500.0_r_tran
    real(kind=r_tran) :: machine_tol
    real(kind=r_tran) :: relative_diff

    transport_metadata => transport_metadata_collection%get_transport_metadata('density')

    ! Initialising fields
    vector_space_w3_ptr => function_space_collection % get_fs( mesh, element_order_h, element_order_v, W3 )

    call field_np1 % initialise( vector_space = vector_space_w3_ptr )
    call field_in % initialise( vector_space = vector_space_w3_ptr )

    call field_np1_input % initialise( vector_space = vector_space_w3_ptr )
    call field_in_input % initialise( vector_space = vector_space_w3_ptr )

    field_np1_inner_prod = 0.0_r_def
    field_in_inner_prod = 0.0_r_def

    ! Initialise values and call the tangent-linear alg.
    call invoke( setval_random( field_np1 ),             &
                 setval_x( field_np1_input, field_np1 ), &
                 setval_random( field_in ),              &
                 setval_x( field_in_input, field_in ) )

    ! Tangent linear
    call tl_end_of_advective_step_alg( field_np1, field_in, transport_metadata )

    ! < Mx, Mx >
    call invoke( x_innerproduct_x( field_np1_inner_prod, field_np1 ), &
                 x_innerproduct_x( field_in_inner_prod, field_in ) )

    inner1 = 0.0_r_tran
    inner1 = inner1 + real( field_np1_inner_prod, r_tran )
    inner1 = inner1 + real( field_in_inner_prod, r_tran )
    write(log_scratch_space, *) "atlt_end_adv_step inner products:"
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "field_np1 inner product = ", real( field_np1_inner_prod, r_tran )
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "field_in inner product = ", real( field_in_inner_prod, r_tran )
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    ! Adjoint alg call and inner products
    fnp1_fnp1_input_inner_prod = 0.0_r_def
    fi_fi_input_inner_prod = 0.0_r_def

    ! Adjoint
    call atl_end_advective_step_alg( field_np1, field_in, transport_metadata )
    ! < AMx, x >
    call invoke( x_innerproduct_y( fnp1_fnp1_input_inner_prod, &
                                   field_np1,                  &
                                   field_np1_input ),          &
                 x_innerproduct_y( fi_fi_input_inner_prod,     &
                                   field_in,                   &
                                   field_in_input ) )

    inner2 = 0.0_r_tran
    inner2 = inner2 + real( fnp1_fnp1_input_inner_prod, r_tran )
    inner2 = inner2 + real( fi_fi_input_inner_prod, r_tran )

    ! Test the inner-product values for equality, allowing for the precision of the active variables
    machine_tol = spacing( max( abs( inner1 ), abs( inner2 ) ) )
    relative_diff = abs( inner1 - inner2 ) / machine_tol
    if ( relative_diff < overall_tolerance ) then
      write( log_scratch_space, * ) "PASSED tl_end_adv_step:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    else
      write( log_scratch_space, * ) "FAILED tl_end_adv_step:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine atlt_end_adv_step_alg

  !=============================================================================
  !> @brief   Adjoint test for atl_end_conservative_step_alg.
  !> @details Passes if adjoint is transpose of tangent linear.
  !>          Determined by testing the equality of inner products <Mx, Mx> and <AMx, x>,
  !>          where M is the tangent linear and A is the adjoint.
  !> @param[in]  mesh         The model mesh
  subroutine atlt_end_con_step_alg( mesh )

    use tl_end_of_transport_step_alg_mod,    only : tl_end_of_conservative_step_alg
    use atl_end_transport_step_alg_mod,      only : atl_end_conservative_step_alg

    implicit none

    ! Arguments
    type(mesh_type), pointer, intent(in) :: mesh

    ! Arguments for tl and adj calls
    type(r_tran_field_type)                :: field_np1
    type(r_tran_field_type)                :: field_in
    type(r_tran_field_type)                :: flux
    type(transport_metadata_type), pointer :: transport_metadata

    ! Copies of input fields used in inner products
    type(r_tran_field_type)                            :: field_np1_input
    type(r_tran_field_type)                            :: field_in_input
    type(r_tran_field_type)                            :: flux_input

    ! Variables used to handle calculations for fields stored in tl_transport_runtime
    type(r_tran_field_type)                            :: tr_field_n_inp
    type(r_tran_field_type), dimension(:), allocatable :: tr_dry_flux_inp
    type(r_tran_field_type), dimension(:), allocatable :: tr_flux_inp
    type(r_tran_field_type), dimension(:), allocatable :: tr_rho_d_inp
    integer(kind=i_def)                                :: num_steps
    integer(kind=i_def)                                :: step
    integer(kind=i_def)                                :: mesh_id

    ! Variables for initialising fields
    type(function_space_type), pointer :: vector_space_w2_ptr
    type(function_space_type), pointer :: vector_space_w3_ptr

    ! Inner products
    real(kind=r_tran) :: inner1
    real(kind=r_def) :: field_np1_inner_prod
    real(kind=r_def) :: field_in_inner_prod
    real(kind=r_def) :: flux_inner_prod
    real(kind=r_tran) :: inner2
    real(kind=r_def) :: fnp1_fnp1_input_inner_prod
    real(kind=r_def) :: fi_fi_input_inner_prod
    real(kind=r_def) :: flux_flux_input_inner_prod

    ! Test parameters and variables
    real(kind=r_tran), parameter :: overall_tolerance = 1500.0_r_tran
    real(kind=r_tran) :: machine_tol
    real(kind=r_tran) :: relative_diff

    mesh_id = mesh % get_id()
    transport_metadata => transport_metadata_collection%get_transport_metadata('density')

    ! Initialising fields
    vector_space_w2_ptr => function_space_collection % get_fs( mesh, element_order_h, element_order_v, W2 )
    vector_space_w3_ptr => function_space_collection % get_fs( mesh, element_order_h, element_order_v, W3 )

    call field_np1 % initialise( vector_space = vector_space_w3_ptr )
    call field_in % initialise( vector_space = vector_space_w3_ptr )
    call flux % initialise( vector_space = vector_space_w2_ptr )

    call field_np1_input % initialise( vector_space = vector_space_w3_ptr )
    call field_in_input % initialise( vector_space = vector_space_w3_ptr )
    call flux_input % initialise( vector_space = vector_space_w2_ptr )

    field_np1_inner_prod = 0.0_r_def
    field_in_inner_prod = 0.0_r_def
    flux_inner_prod = 0.0_r_def

    ! Initialise values and call the tangent-linear alg.
    call invoke( setval_random( field_np1 ),             &
                 setval_x( field_np1_input, field_np1 ), &
                 setval_random( field_in ),              &
                 setval_x( field_in_input, field_in ),   &
                 setval_random( flux ),                  &
                 setval_x( flux_input, flux ) )

    ! Setting up flux input for tl_transport_runtime, saving flux input values
    ! in scoped array. An extra rho_d field is stored at num_dry_steps + 1.
    num_steps = tl_transport_runtime % get_num_dry_steps()
    allocate( tr_dry_flux_inp( num_steps ) )
    allocate( tr_flux_inp( num_steps - 1 ) )
    allocate( tr_rho_d_inp( num_steps + 1 ) )
    call init_atl_end_con_step_fields( mesh, num_steps, tr_field_n_inp, tr_dry_flux_inp, tr_flux_inp, tr_rho_d_inp )

    ! Tangent linear
    do step = 1, num_steps
      call tl_end_of_conservative_step_alg( field_np1, field_in, flux, transport_metadata )
    end do
    call tl_transport_runtime % dec_tracer_step_ctr()

    ! < Mx, Mx >
    call invoke( x_innerproduct_x( field_np1_inner_prod, field_np1 ), &
                 x_innerproduct_x( field_in_inner_prod, field_in ),   &
                 x_innerproduct_x( flux_inner_prod, flux ) )

    inner1 = 0.0_r_tran
    inner1 = inner1 + real( field_np1_inner_prod, r_tran )
    inner1 = inner1 + real( field_in_inner_prod, r_tran )
    inner1 = inner1 + real( flux_inner_prod, r_tran )
    write(log_scratch_space, *) "atlt_end_con_step inner products:"
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "field_np1 inner product = ", real( field_np1_inner_prod, r_tran )
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "field_in inner product = ", real( field_in_inner_prod, r_tran )
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    write(log_scratch_space, *) "flux inner product = ", real( flux_inner_prod, r_tran )
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    call dry_flux_prod_rtran( inner1, mesh_id )
    call flux_prod_rtran( inner1, mesh_id )
    call rho_d_prod_rtran( inner1, mesh )
    call field_n_prod_rtran( inner1 )

    ! Adjoint alg call and inner products
    fnp1_fnp1_input_inner_prod = 0.0_r_def
    fi_fi_input_inner_prod = 0.0_r_def
    flux_flux_input_inner_prod = 0.0_r_def

    ! Adjoint
    do step = num_steps, 1, -1
      call atl_end_conservative_step_alg( field_np1, field_in, flux, transport_metadata )
      call tl_transport_runtime % dec_tracer_step_ctr()
    end do

    ! < AMx, x >
    call invoke( x_innerproduct_y( fnp1_fnp1_input_inner_prod, &
                                   field_np1,                  &
                                   field_np1_input ),          &
                 x_innerproduct_y( fi_fi_input_inner_prod,     &
                                   field_in,                   &
                                   field_in_input ),           &
                 x_innerproduct_y( flux_flux_input_inner_prod, &
                                   flux,                       &
                                   flux_input ) )

    inner2 = 0.0_r_tran
    inner2 = inner2 + real( fnp1_fnp1_input_inner_prod, r_tran )
    inner2 = inner2 + real( fi_fi_input_inner_prod, r_tran )
    inner2 = inner2 + real( flux_flux_input_inner_prod, r_tran )
    call dry_flux_inp_prod_rtran( inner2, mesh_id, tr_dry_flux_inp )
    call flux_inp_prod_rtran( inner2, mesh_id, tr_flux_inp )
    call rho_d_inp_prod_rtran( inner2, mesh, tr_rho_d_inp )
    call field_n_inp_prod_rtran( inner2, tr_field_n_inp )

    ! Test the inner-product values for equality, allowing for the precision of the active variables
    machine_tol = spacing( max( abs( inner1 ), abs( inner2 ) ) )
    relative_diff = abs( inner1 - inner2 ) / machine_tol
    if ( relative_diff < overall_tolerance ) then
      write( log_scratch_space, * ) "PASSED tl_end_con_step:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    else
      write( log_scratch_space, * ) "FAILED tl_end_con_step:", inner1, inner2, relative_diff
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine atlt_end_con_step_alg

end module atlt_end_transport_step_alg_mod
